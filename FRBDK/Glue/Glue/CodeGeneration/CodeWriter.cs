using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using FlatRedBall.Glue.CodeGeneration.CodeBuilder;
using FlatRedBall.IO;
using FlatRedBall.Utilities;
using FlatRedBall.Instructions.Reflection;
using FlatRedBall.Glue.Elements;
using FlatRedBall.Glue.SaveClasses;
using FlatRedBall.Glue.CodeGeneration;
using FlatRedBall.Glue.Events;
using FlatRedBall.Glue.Plugins.Performance;
using FlatRedBall.Glue.Plugins;
using FlatRedBall.Glue.Plugins.Interfaces;
using FlatRedBall.Glue.IO;
using System.IO;
using FlatRedBall.Glue.AutomatedGlue;
using FlatRedBall.Glue.Plugins.ExportedImplementations;
using System.Threading.Tasks;
using FlatRedBall.Glue.Managers;
using FlatRedBall.Glue.Plugins.EmbeddedPlugins.FactoryPlugin;

namespace FlatRedBall.Glue.Parsing;

#region Class Properties Struct

/// <summary>
/// Define the properties of a <see langword="class" /> to be generated.
/// </summary>
public struct ClassProperties
{
    /// <summary>
    /// The namespace the <see langword="class" /> belongs to.
    /// </summary>
    public string NamespaceName;

    /// <summary>
    /// The name of the <see langword="class" />.
    /// </summary>
    public string ClassName;

    /// <summary>
    /// The member fields and properties of the <see langword="class" />.
    /// </summary>
    public List<TypedMemberBase> Members;

    /// <summary>
    /// The untyped members of the <see langword="class" />.
    /// </summary>
    public Dictionary<string, string> UntypedMembers;

    /// <summary>
    /// Whether the <see langword="class" /> is <see langword="static" />
    /// </summary>
    public bool IsStatic;

    /// <summary>
    /// Whether this only contains <see langword="partial" /> <see langword="class" /> content.
    /// </summary>
    public bool Partial;

    /// <summary>
    /// Whether the class needs to generate headers.
    /// </summary>
    public bool RequiresAutoGeneratedHeaders;

    /// <summary>
    /// The using statements for the <see langword="class" />.
    /// </summary>
    public List<string> UsingStatements;

    /// <summary>
    /// The methods assigned to the <see langword="class" />.
    /// </summary>
    public ICodeBlock MethodContent;
}

#endregion

/// <summary>
/// Provides methods to generate code for Glue elements.
/// </summary>
public static class CodeWriter
{
    #region Fields

    /// <summary>
    /// Template code to define a screen.
    /// </summary>
    public const string ScreenTemplateCode =
@"using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

using FlatRedBall;
using FlatRedBall.Input;
using FlatRedBall.Instructions;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Graphics.Animation;
using FlatRedBall.Gui;
using FlatRedBall.Math;
using FlatRedBall.Math.Geometry;
using FlatRedBall.Localization;
using Microsoft.Xna.Framework;

// Additional usings


namespace FlatRedBallAddOns.Screens
{
    public partial class ScreenTemplate
    {
        private void CustomInitialize()
        {
            
        }

        private void CustomActivity(bool firstTimeCalled)
        {
            
        }

        private void CustomDestroy()
        {
            
        }

        private static void CustomLoadStaticContent(string contentManagerName)
        {
            
        }
    }
}
";
    
    /// <summary>
    /// Template code for custom entities.
    /// </summary>
    public const string EntityTemplateCode =
@"using System;
using System.Collections.Generic;
using System.Text;
using FlatRedBall;
using FlatRedBall.Input;
using FlatRedBall.Instructions;
using FlatRedBall.AI.Pathfinding;
using FlatRedBall.Graphics.Animation;
using FlatRedBall.Graphics.Particle;
using FlatRedBall.Math.Geometry;
using Microsoft.Xna.Framework;

namespace FlatRedBallAddOns.Entities
{
    public partial class GlueEntityTemplate
    {
        /// <summary>
        /// Initialization logic which is executed only one time for this Entity (unless the Entity is pooled).
        /// This method is called when the Entity is added to managers. Entities which are instantiated but not
        /// added to managers will not have this method called.
        /// </summary>
        private void CustomInitialize()
        {
            
        }

        private void CustomActivity()
        {
            
        }

        private void CustomDestroy()
        {
            
        }

        private static void CustomLoadStaticContent(string contentManagerName)
        {
            
        }
    }
}
";



    #endregion

    #region Properties 

    /// <summary>
    /// List of code generators that are in use.
    /// </summary>
    public static List<ElementComponentCodeGenerator> CodeGenerators { get; }

    /// <summary>
    /// List of code generators for global content in the game.
    /// </summary>
    public static List<GlobalContentCodeGeneratorBase> GlobalContentCodeGenerators { get; }
    
    #endregion

    #region Methods
    
    /// <summary>
    /// Static constructor to initialize the <see cref="CodeGenerators"/> list.
    /// </summary>
    static CodeWriter()
    {
        CodeGenerators = new List<ElementComponentCodeGenerator>
        {
            new ErrorCheckingCodeGenerator(),
            new ScrollableListCodeGenerator(),
            new StateCodeGenerator(),
            new FactoryElementGeneratorEarly(),
            new FactoryElementCodeGenerator(),
            new ReferencedFileSaveCodeGenerator(),
            new NamedObjectSaveCodeGenerator(),
            new CustomVariableCodeGenerator(),
            new EventCodeGenerator(),
            new PooledCodeGenerator(),
            new IVisibleCodeGenerator(),
            new IWindowCodeGenerator(),
            new ITiledTileMetadataCodeGenerator(),
            new PauseCodeGenerator(),
            new LoadingScreenCodeGenerator()
        };

        GlobalContentCodeGenerators = new List<GlobalContentCodeGeneratorBase>();
    }

    /// <summary>
    /// Generates code for the specified <see cref="GlueElement"/>.
    /// </summary>
    /// <param name="element">Element to generate code for.</param>
    /// <returns><see cref="Task"/> completion</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="element"/> is <see langword="null" /></exception>
    /// <exception cref="Exception">Thrown if <see cref="ReferencedFileSaveCodeGenerator.GlobalContentFilesDictionary"/> is <see langword="null" />.</exception>
    public static async Task GenerateCode(GlueElement element)
    {
        TaskManager.Self.WarnIfNotInTask();

        #region Prepare for generation

        if (element == null)
        {
            throw new ArgumentNullException(nameof(element));
        }

        // Since anything can modify an enumeration value we want to make sure that
        // it's proper before generating code for it:
        // If enumeration values don't work property let's just print some output and carry on
        try
        {
            element.FixEnumerationValues();
        }
        catch (Exception e)
        {
            PluginManager.ReceiveError("Error fixing enumerations for " + element + ": " + e.ToString());
        }


        // Do this before doing anything else since 
        // these reusable entire file RFS's are used 
        // in other code.
        RefreshReusableEntireFileRfses(element);
        #endregion

        #region Event Generation

        EventCodeGenerator.GenerateEventGeneratedFile(element);

        if (element.Events.Count != 0)
        {
            string sharedCodeFullFileName =
                EventResponseSave.GetSharedCodeFullFileName(element, FileManager.GetDirectory(GlueState.Self.GlueProjectFileName.FullPath));

            EventCodeGenerator.CreateEmptyCodeIfNecessary(element,
                sharedCodeFullFileName, false);
        }

        EventCodeGenerator.AddStubsForCustomEvents(element);

        #endregion

        CreateGeneratedFileIfNecessary(element);

        foreach (PluginManager pluginManager in PluginManagerBase.GetInstances().Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.CallCodeGenerationStart(pluginManager, element);
        }

        if (GlobalContentCodeGenerator.SuppressGlobalContentDictionaryRefresh == false)
        {
            ReferencedFileSaveCodeGenerator.RefreshGlobalContentDictionary();
        }

        if (ReferencedFileSaveCodeGenerator.GlobalContentFilesDictionary == null)
        {
            throw new Exception("Global content files dictionary should not be null");
        }
        
        string classNamespace = GetGlueElementNamespace(element);

        CodeDocument rootBlock = new(0);

        GenerateDefines(rootBlock);

        UsingsCodeGenerator.GenerateUsingStatements(rootBlock, element);


        CodeBlockNamespace namespaceBlock = rootBlock.Namespace(classNamespace);

        ICodeBlock codeBlock = GenerateClassHeader(element, namespaceBlock);


        GenerateFieldsAndProperties(element, codeBlock);

        GenerateConstructors(element, codeBlock);

        GenerateInitialize(element, codeBlock);

        GenerateAddToManagers(element, codeBlock);

        GenerateActivity(codeBlock, element);

        if(GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.ScreensHaveActivityEditMode)
        {
            GenerateActivityEditMode(codeBlock, element);
        }

        GenerateDestroy(element, codeBlock);

        GenerateMethods(codeBlock, element);

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateAdditionalClasses(namespaceBlock, element);
        }

        string generatedCodeFileName = element.Name + ".Generated.cs";
        string contentsToSave = rootBlock.ToString();

        SaveFileContents(contentsToSave, FileManager.RelativeDirectory + generatedCodeFileName, true);

        #region Extra stuff if it's an EntitySave

        if (element is EntitySave entitySave)
        {
            #region If this thing is created by other entities, then we should make it IPoolable

            if (entitySave.CreatedByOtherEntities && !entitySave.IsAbstract)
            {
                FactoryElementCodeGenerator.GenerateAndAddFactoryToProjectClass(entitySave);
            }

            #endregion

        }
        #endregion

        // This code will create and add above, but if the file already exists, the code above won't re-add it to the 
        // project. This is a last chance to add it if necessary:
        await GlueCommands.Self.ProjectCommands.TryAddCodeFileToProjectAsync(GetAbsoluteGeneratedCodeFileFor(element), saveOnAdd: true);
    }

    #region Predefines like #if ANDROID


    /// <summary>
    /// Generating define blocks to support different platforms, e.g. Android or iOS.
    /// </summary>
    /// <param name="rootBlock">Root block of the code.</param>
    public static void GenerateDefines(ICodeBlock rootBlock)
    {
        rootBlock.Line("#if ANDROID || IOS || DESKTOP_GL");
        rootBlock.Line("#define REQUIRES_PRIMARY_THREAD_LOADING");
        rootBlock.Line("#endif");

        GlueProjectSave project = GlueState.Self.CurrentGlueProject;
        if(project.FileVersion >= (int)GlueProjectSave.GluxVersions.SupportsEditMode)
        {
            rootBlock.Line("#define SUPPORTS_GLUEVIEW_2");
        }
        else
        {
            rootBlock.Line($"// The project is not new enough to support GlueView 2. It is on version {project.FileVersion}");
            rootBlock.Line("//#define SUPPORTS_GLUEVIEW_2");

        }
    }

    #endregion

    #region Namespace

    /// <summary>
    /// Retrieves the namespace for the specified <see cref="GlueElement"/>.
    /// </summary>
    /// <param name="element">Element to retrieve the namespace for</param>
    /// <returns>Retrieved namespace</returns>
    public static string GetGlueElementNamespace(GlueElement element)
    {
        string classNamespace = ProjectManager.ProjectNamespace;

        string directory = FileManager.MakeRelative(FileManager.GetDirectory(element.Name));

        string entitiesOrScreens = element is EntitySave ? "Entities" : "Screens";

        if (!directory.Equals($"{entitiesOrScreens}/", StringComparison.OrdinalIgnoreCase))
        {
            string relativeDirectory = FileManager.MakeRelative(directory);
            relativeDirectory = relativeDirectory.Substring(0, relativeDirectory.Length - 1);
            relativeDirectory = relativeDirectory.Replace('/', '.');

            classNamespace += "." + relativeDirectory;
        }
        else
        {
            classNamespace += "." + entitiesOrScreens;
        }
        
        return classNamespace;
    }

    #endregion

    #region Class Header

    /// <summary>
    /// Generates a <see langword="class" /> header for the specified <see cref="IElement"/> and writes this to <paramref name="namespaceBlock"/>.
    /// </summary>
    /// <param name="element">Element to generate the <see langword="class" /> header for</param>
    /// <param name="namespaceBlock">Code block to write to.</param>
    /// <returns>Code block for the <see langword="class" /></returns>
    private static ICodeBlock GenerateClassHeader(IElement element, ICodeBlock namespaceBlock)
    {
        string inheritance = GetInheritance(element);

        if(!String.IsNullOrEmpty(inheritance))
        {
            inheritance = " : " + inheritance;
        }

        bool isAbstract = element.AllNamedObjects.Any(item => item.SetByDerived);

        string optionalAbstractString = isAbstract ? "abstract " : String.Empty;

        ICodeBlock classCodeBlock = namespaceBlock.Class($"public {optionalAbstractString}partial", FileManager.RemovePath( element.Name), inheritance);

        return classCodeBlock;
    }

    /// <summary>
    /// Retrieves the inheritance stack for the specified <see cref="IElement"/>, as a comma separated string.
    /// </summary>
    /// <param name="element">Element to get the inheritance from.</param>
    /// <returns>Inheritances of the element, comma separated.</returns>
    private static string GetInheritance(IElement element)
    {
        string whatToInheritFrom;
        
        if (element is EntitySave entitySave)
        {
            List<string> inheritanceList =
                InheritanceCodeWriter.Self.GetInheritanceList(entitySave, out EntitySave _);

            whatToInheritFrom = String.Join(", ", inheritanceList);
        }
        else // Screen
        {
            bool inherits = !String.IsNullOrEmpty(element.BaseElement) && element.BaseElement != "<NONE>";
            whatToInheritFrom = inherits ? element.BaseElement.Replace("\\", ".") : "FlatRedBall.Screens.Screen";

            List<string> inheritanceList = new();
            foreach (ElementComponentCodeGenerator generator in CodeGenerators)
            {
                generator.AddInheritedTypesToList(inheritanceList, element);
            }

            foreach (var item in inheritanceList)
            {
                whatToInheritFrom += ", " + item;
            }
        }

        return whatToInheritFrom;
    }

    #endregion

    #region Fields/Properties



    /// <summary>
    /// Generates fields and properties for <paramref name="glueElement"/> and writes this to <paramref name="codeBlock"/>.
    /// </summary>
    /// <param name="glueElement">Element to write the fields and properties for</param>
    /// <param name="codeBlock">Code block to write the fields and properties to</param>
    /// <exception cref="Exception">If a code writer is in a <see langword="null"/> state,
    /// or if an error occurs while generating fields.</exception>
    internal static ICodeBlock GenerateFieldsAndProperties(IElement glueElement, ICodeBlock codeBlock)
    {
        if(glueElement is EntitySave entitySave)
        {
            EntityCodeWriter.GenerateFieldsAndProperties(entitySave, codeBlock);
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            if (codeGenerator == null)
            {
                throw new Exception("The CodeWriter contains a null code generator.  A plugin must have added this");
            }

            try
            {
                codeGenerator.GenerateFields(codeBlock, glueElement);
            }
            catch (Exception e)
            {
                throw new Exception("Error generating fields in generator " + codeGenerator.GetType().Name + 
                    "\n\n" + e.ToString());

            }
        }

        PerformancePluginCodeGenerator.GenerateFields(glueElement, codeBlock);

        // No need to create LayerProvidedByContainer if this inherits from another object.
        if (glueElement is EntitySave && !glueElement.InheritsFromEntity())
        {
            // Add the layer that is going to get assigned in generated code
            codeBlock.Line("protected FlatRedBall.Graphics.Layer LayerProvidedByContainer = null;");
        }
        

        return codeBlock;


    }

    #endregion

    #region Constructor


    /// <summary>
    /// Generates constructor(s) for <paramref name="element"/> and writes them to <paramref name="codeBlock"/>.
    /// </summary>
    /// <param name="element">Element to write constructor(s) for.</param>
    /// <param name="codeBlock">Code block to write the constructor(s) to.</param>
    private static void GenerateConstructors(GlueElement element, ICodeBlock codeBlock)
    {
        ICodeBlock constructor;

        string elementName = FileManager.RemovePath(element.Name);

        if (element is EntitySave entitySave)
        {
            codeBlock.Constructor("public", elementName, "", "this(FlatRedBall.Screens.ScreenManager.CurrentScreen.ContentManagerName, true)");

            codeBlock.Constructor("public", elementName, "string contentManagerName", "this(contentManagerName, true)");

            bool inheritsFromEntity = element.InheritsFromEntity();
            constructor = codeBlock.Constructor("public", elementName, "string contentManagerName, bool addToManagers",
                inheritsFromEntity
                    ? "base(contentManagerName, addToManagers)"
                    : "base()");

            constructor.Line(entitySave.UseGlobalContent
                ? "ContentManagerName = FlatRedBall.FlatRedBallServices.GlobalContentManager;"
                : "ContentManagerName = contentManagerName;");

            // See below on why we do this here
            CallElementComponentCodeGeneratorGenerateConstructor(element, constructor);

            // The base will handle this
            if (!element.InheritsFromEntity())
            {
                constructor.Line("InitializeEntity(addToManagers);");
            }
        }
        else // screen save
        {
            string contentManagerName = (element.UseGlobalContent) ? "\"Global\"" : $"\"{elementName}\"";

            // Feb 13, 2022,
            // This constructor enables the old FRB code to call in to this with no parameters without breaking reflection
            // No need to change it since screens are almost never explicitly constructed
            codeBlock.Constructor("public", elementName, "", $"this ({contentManagerName})");

            constructor = codeBlock.Constructor("public", elementName, "string contentManagerName", $"base (contentManagerName)");

            CallElementComponentCodeGeneratorGenerateConstructor(element, constructor);
        }

        return;
        
        static void CallElementComponentCodeGeneratorGenerateConstructor(IElement element, ICodeBlock constructor)
        {
            foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
            {
                try
                {
                    codeGenerator.GenerateConstructor(constructor, element);
                }
                catch (Exception e)
                {
                    GlueCommands.Self.PrintError(
                        $"Error calling GenerateConstructor on {codeGenerator.GetType()}:\n{e}");
                }
            }
        }
    }
    #endregion

    #region Load Static Content


    /// <summary>
    /// Generates static content to load for the file.
    /// </summary>
    /// <param name="codeBlock">Code block to write the content to</param>
    /// <param name="element">Element to write the content for</param>
    private static void GenerateLoadStaticContent(ICodeBlock codeBlock, GlueElement element)
    {
        bool inheritsFromElement = element.InheritsFromElement();

        codeBlock = codeBlock.Function(StringHelper.SpaceStrings(
                                                    "public",
                                                    "static",
                                                    inheritsFromElement ? "new" : null,
                                                    "void"),
                                     "LoadStaticContent",
                                     "string contentManagerName");

        if (element is EntitySave)
        {
            // Currently only EntitySaves have access to LoadedContentManagers
            // The reason we have this here is because if two Entities reference
            // each other ( https://github.com/vchelaru/FlatRedBall/issues/1017 )
            // then an infinitely recursive call can happen.  We can use LoadedContentManagers
            // to prevent this. We do this here instead of in the ReferencedFileSave generated code
            // because we want to exit out immediately before anything else has a chance to run. The 
            // RFS code generator can't do this without some hacks.
            codeBlock.If("LoadedContentManagers.Contains(contentManagerName)")
                .Line("return;");
        }


        PerformancePluginCodeGenerator.GenerateStart(element, codeBlock, "LoadStaticContent");

        codeBlock.Line("bool oldShapeManagerSuppressAdd = FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue;");
        codeBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = true;");

        codeBlock.If("string.IsNullOrEmpty(contentManagerName)")
            .Line("throw new System.ArgumentException(\"contentManagerName cannot be empty or null\");")
            .End();

        #region Set the ContentManagerName ( do this BEFORE checking for IsStaticContentLoaded )

        if (element is EntitySave entitySave)
        {
            if (entitySave.UseGlobalContent)
            {
                codeBlock.Line("// Set to use global content");
                codeBlock.Line("contentManagerName = FlatRedBall.FlatRedBallServices.GlobalContentManager;");
            }
            codeBlock.Line("ContentManagerName = contentManagerName;");
        }

        #endregion


        if (inheritsFromElement)
        {
            codeBlock.Line("global::" + ProjectManager.ProjectNamespace + "." + element.BaseElement.Replace("\\", ".")  + ".LoadStaticContent(contentManagerName);");
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item=>(int)item.CodeLocation))
        {
            codeBlock = codeGenerator.GenerateLoadStaticContent(codeBlock, element);
        }
        
        #region Register the unload for EntitySaves

        // Vic says - do we want this for Screens too?
        // I don't think we do because Screens can just null- out stuff in their Destroy method.  There's only one of them around at a time.

        if (element is EntitySave save)
        {
            if (!save.UseGlobalContent)
            {
                ICodeBlock ifBlock = codeBlock.If("registerUnload && ContentManagerName != FlatRedBall.FlatRedBallServices.GlobalContentManager");
                ReferencedFileSaveCodeGenerator.AppendAddUnloadMethod(ifBlock, save);
            }
        }

        #endregion
 
        codeBlock.Line("CustomLoadStaticContent(contentManagerName);");

        codeBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = oldShapeManagerSuppressAdd;");

        PerformancePluginCodeGenerator.GenerateEnd(element, codeBlock, "LoadStaticContent");
    }

    #endregion

    /// <summary>
    /// Save the file contents to the specified <paramref name="fileName"/>
    /// </summary>
    /// <param name="fileContents">Text contents of the file</param>
    /// <param name="fileName">File directory</param>
    /// <param name="tryAgain">Whether to retry on failure</param>
    /// <param name="standardizeNewlines"></param>
    /// <returns><see langword="true" /> on success.</returns>
    /// <exception cref="ArgumentNullException">If <paramref name="fileName"/> is <see langword="null" /></exception>
    public static bool SaveFileContents(string fileContents, string fileName, bool tryAgain, bool standardizeNewlines = true)
    {
        ArgumentNullException.ThrowIfNull(fileName, nameof(fileName));

        if (standardizeNewlines && !String.IsNullOrEmpty(fileContents))
        {
            // from: https://stackoverflow.com/questions/31053/regex-c-replace-n-with-r-n
            // for: https://github.com/vchelaru/FlatRedBall/issues/103
            fileContents = System.Text.RegularExpressions.Regex.Replace(fileContents, "(?<!\r)\n", "\r\n");
        }

        bool isReadOnly = File.Exists(fileName) && new FileInfo(fileName).IsReadOnly;

        if (isReadOnly)
        {
            GlueGui.ShowMessageBox("Could not save file\n\n" + fileName + "\n\nbecause it is marked read-only.");
        }
        else
        {
            if(fileName.Contains(".generated.", StringComparison.InvariantCultureIgnoreCase))
            {
                fileContents = $"#pragma warning disable\r\n{fileContents}";
            }

            if (!tryAgain)
            {
                GlueCommands.Self.FileCommands.SaveIfDiffers(fileName, fileContents, ignoreNextChange: true);
            }
            else
            {
                try
                {
                    GlueCommands.Self.TryMultipleTimes(() =>
                    {
                        GlueCommands.Self.FileCommands.SaveIfDiffers(fileName, fileContents, ignoreNextChange: true);
                    });
                }
                catch
                {
                    string errorMessage =
                        $"Could not generate the file {fileName}\n\nTry manually re-generating this through Glue.  This is not a fatal error.";

                    GlueCommands.Self.PrintOutput(errorMessage);
                }
            }
        }
        return tryAgain;
    }


    /// <summary>
    /// Get the absolute file path for the generated code file for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to save</param>
    /// <returns>Found <see cref="FilePath"/></returns>
    public static FilePath GetAbsoluteGeneratedCodeFileFor(GlueElement saveObject)
    {
        string fileName = saveObject.Name + ".Generated.cs";

        FilePath absoluteFileName = fileName;

        if (FileManager.IsRelative(fileName))
        {
            absoluteFileName = GlueState.Self.CurrentGlueProjectDirectory + fileName;
        }

        return absoluteFileName;
    }

    /// <summary>
    /// Generate a file if it doesn't exist for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to generate the file for, it doesn't exist.</param>
    public static void CreateGeneratedFileIfNecessary(GlueElement saveObject)
    {
        FilePath absoluteFilePath = GetAbsoluteGeneratedCodeFileFor(saveObject);
        if (absoluteFilePath.Exists() == false)
        {
            CreateAndAddGeneratedFile(saveObject);
        }
    }

    /// <summary>
    /// Generate a new file for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to generate</param>
    public static void CreateAndAddGeneratedFile(IElement saveObject)
    {
        // let's make a generated file
        string fileName = saveObject.Name + ".Generated.cs";
        ProjectManager.CodeProjectHelper.CreateAndAddPartialGeneratedCodeFile(fileName, true);
        PluginManager.ReceiveOutput("Glue has created the generated file " + FileManager.RelativeDirectory + saveObject.Name + ".cs");
    }

    /// <summary>
    /// Reusable entire file RFSes for the entire project.
    /// </summary>
    public static Dictionary<string, string> ReusableEntireFileRfses { get; } = new Dictionary<string, string>();


    /// <summary>
    /// Refresh the reusable entire file RFSes for the specified <paramref name="element"/>.
    /// </summary>
    /// <param name="element">Element to refresh the RFSes for.</param>
    private static void RefreshReusableEntireFileRfses(IElement element)
    {
        ReusableEntireFileRfses.Clear();

        // Fill the mReusableEntireFileRfses
        foreach (NamedObjectSave nos in element.NamedObjects)
        {
            if (nos.IsEntireFile && nos.SourceFile != null && ReusableEntireFileRfses.ContainsKey(nos.SourceFile) == false)
            {
                ReusableEntireFileRfses.Add(nos.SourceFile, nos.FieldName);
            }
        }
        IVisibleCodeGenerator.ReusableEntireFileRfses = ReusableEntireFileRfses;
        NamedObjectSaveCodeGenerator.ReusableEntireFileRfses = ReusableEntireFileRfses;
    }

    #region Initialize

    /// <summary>
    /// Generate the header for the Initialize() method of <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to generate the method for</param>
    /// <param name="codeBlock">Code block to write the code to</param>
    internal static ICodeBlock GenerateInitialize(GlueElement saveObject, ICodeBlock codeBlock)
    {
        TaskManager.Self.WarnIfNotInTask();

        string initializePre;
        string initializeMethodCall;
        if (saveObject is ScreenSave)
        {
            initializePre = "public override void";
            initializeMethodCall = "Initialize";
        }
        else
        {
            initializeMethodCall = "InitializeEntity";

            if (saveObject.InheritsFromElement())
            {
                initializePre = "protected override void";
            }
            else
            {
                initializePre = "protected virtual void";
            }
        }

        codeBlock = codeBlock.Function(initializePre, initializeMethodCall, "bool addToManagers");

        // Start measuring performance before anything else
        PerformancePluginCodeGenerator.GenerateStartTimingInitialize(saveObject, codeBlock);

        PerformancePluginCodeGenerator.SaveObject = saveObject;
        PerformancePluginCodeGenerator.CodeBlock = codeBlock;

        PerformancePluginCodeGenerator.GenerateStart("CustomLoadStaticContent from Initialize");

        // Load static content before looping through the CodeGenerators
        // The reason for this is there is a ReferencedFileSaveCodeGenerator
        // which needs to work with static RFS's which are instantiated here
        codeBlock.Line("LoadStaticContent(ContentManagerName);");

        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("General Initialize internals");

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            try
            {
                codeGenerator.GenerateInitialize(codeBlock, saveObject);
            }
            catch (Exception e)
            {
                GlueCommands.Self.PrintError($"Error calling GenerateInitialize on {codeGenerator.GetType()}:\n{e}");
            }
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            try
            {
                codeGenerator.GenerateInitializeLate(codeBlock, saveObject);
            }
            catch(Exception e)
            {
                GlueCommands.Self.PrintError($"Error calling GenerateInitializeLate on {codeGenerator.GetType()}:\n{e}");
            }
        }

        NamedObjectSaveCodeGenerator.GenerateCollisionRelationships(codeBlock, saveObject);

        if (saveObject is ScreenSave screenSave)
        {
            codeBlock._();

            if (screenSave.IsRequiredAtStartup)
            {
                string startupScreen = GlueCommands.Self.GluxCommands.StartUpScreenName;

                string qualifiedName = ProjectManager.ProjectNamespace + "." + startupScreen.Replace("\\", ".");

                codeBlock.Line($"this.NextScreen = typeof({qualifiedName}).FullName;");
            }

            if (screenSave.UseGlobalContent)
            {
                // no need to do anything here because Screens are smart enough to know to not load if they
                // are using global content
            }
        }

        codeBlock._();
        PerformancePluginCodeGenerator.GenerateEnd();

        #region PostInitializeCode

        PerformancePluginCodeGenerator.GenerateStart("Post Initialize");

        if (saveObject.InheritsFromElement() == false)
        {
            codeBlock.Line("PostInitialize();");
        }
        PerformancePluginCodeGenerator.GenerateEnd();

        #endregion

        PerformancePluginCodeGenerator.GenerateStart("Base.Initialize");

        InheritanceCodeWriter.Self.WriteBaseInitialize(saveObject, codeBlock);

        if(saveObject is ScreenSave && GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.ScreenIsINameable)
        {
            string name = saveObject.GetStrippedName();
            codeBlock.Line($"this.Name = \"{name}\";");
        }

        // This needs to happen after calling WriteBaseInitialize so that the derived overwrites the base
        if (saveObject is ScreenSave asScreenSave)
        {
            if (!String.IsNullOrEmpty(asScreenSave.NextScreen))
            {
                string nameToUse = $"{ProjectManager.ProjectNamespace}.{asScreenSave.NextScreen.Replace("\\", ".")}";

                codeBlock.Line($"this.NextScreen = typeof({nameToUse}).FullName;");
            }

        }
        PerformancePluginCodeGenerator.GenerateEnd();

        // I think we want to set this after calling base.Initialize so that the base
        // has a chance to set values on derived objects
        PerformancePluginCodeGenerator.GenerateStart("Reset Variables");
        // Now that variables are set, we can record reset variables
        NamedObjectSaveCodeGenerator.AssignResetVariables(codeBlock, saveObject);
        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("AddToManagers");
        
        #region If shouldCallAddToManagers, call AddToManagers
        bool shouldCallAddToManagers = !saveObject.InheritsFromElement();
        if (shouldCallAddToManagers)
        {
            ICodeBlock ifBlock = codeBlock
                .If("addToManagers");
            if (saveObject is ScreenSave)
            {
                ifBlock.Line("AddToManagers();");
            }
            else
            {
                ifBlock.Line("AddToManagers(null);");
            }
        }

        #endregion
        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateEndTimingInitialize(saveObject, codeBlock);

        return codeBlock;
    }

    #endregion

    /// <summary>
    /// Returns <see langword="true" /> if the specified <paramref name="element"/> is on its own layer.
    /// </summary>
    /// <param name="element">Element to check</param>
    /// <returns><see langword="true" /> if the specified <paramref name="element"/> is on its own layer.</returns>
    [Obsolete("Don't use this anymore. As of April 2024 - this is very old and is likely not used anymore in modern projects." +
              " We now use explicit layers.")]
    public static bool IsOnOwnLayer(IElement element)
    {
        if (element is EntitySave)
        {
            // The AddToManagers for EntitySaves takes a layer.  We should always
            // use this argument, but make sure all methods that take layered arguments
            // can work with null
            return true;

        }
        else
        {
            return ((element as ScreenSave)!).IsOnOwnLayer;
        }
    }

    #region Add To Managers

    /// <summary>
    /// Generate the AddToManagers method for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateAddToManagers(IElement saveObject, ICodeBlock codeBlock)
    {
        ICodeBlock currentBlock = codeBlock;

        bool isEntity = saveObject is EntitySave;
        bool isScreen = !isEntity;
  
        #region Generate the method header

        if (isScreen)
        {
            currentBlock = currentBlock
                .Function("public override void", "AddToManagers", "");
        }
        else if (saveObject.InheritsFromElement()) // it's an EntitySave
        {
            currentBlock = currentBlock
                .Function("public override void", "AddToManagers", "FlatRedBall.Graphics.Layer layerToAddTo");
        }
        else // It's a base EntitySave
        {
            currentBlock = currentBlock
                .Function("public virtual void", "AddToManagers", "FlatRedBall.Graphics.Layer layerToAddTo");
        }
        #endregion

        if(isScreen)
        {
            // Screen.cs (in FlatRedBall Engine) assign mTimeScreenWasCreated. Unfortunately
            // that happens in the base class after all instances in the derived screen are created
            // and after their CustomInitialize is called. That CustomInitialize may use the TimeManager.CurrentScreenTime
            // which depends on the mTimeScreenWasCreated value being set. Therefore we'll force set this here. It may get set
            // multiple times but that should be okay:
            currentBlock.Line("mAccumulatedPausedTime = TimeManager.CurrentTime;");
            currentBlock.Line("mTimeScreenWasCreated = FlatRedBall.TimeManager.CurrentTime;");
        }

        PerformancePluginCodeGenerator.SaveObject = saveObject;
        PerformancePluginCodeGenerator.CodeBlock = currentBlock;

        PerformancePluginCodeGenerator.GenerateStart("Pooled PostInitialize");

        #region Call PostInitialize *again* if this is a pooled, base Entity

        // May 24, 2022
        // This code is quite
        // old, but I believe this
        // is necessary because it re-initializes
        // the entity after being destroyed. "old" recycled
        // entities may have their internal objects shifted around,
        // so a post-init will reset them. 
        FactoryElementCodeGenerator.CallPostInitializeIfNecessary(saveObject, currentBlock);


        #endregion

        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("Layer for this code");


        #region Generate layer if a screen

        // Only Screens need to define a layer.  Otherwise, the layer is fed to the Entity
        if (IsOnOwnLayer(saveObject) && isScreen)
        {
            currentBlock.Line("mLayer = SpriteManager.AddLayer();");
        }

        #endregion

        #region Assign the layer so that custom code can get to it

        if (isEntity)
        {
            currentBlock.Line("LayerProvidedByContainer = layerToAddTo;");
        } 

        #endregion

        PerformancePluginCodeGenerator.GenerateEnd();

        GenerateAddThisEntityToManagers(saveObject, currentBlock);

        const string addFilesToManagers = "Add Files to Managers";
        PerformancePluginCodeGenerator.GenerateStart(saveObject, currentBlock, addFilesToManagers);
 
        // Add referenced files before adding objects because the objects
        // may be aliases for the files (if using Entire File) and may add them
        // to layers.
        ReferencedFileSaveCodeGenerator.GenerateAddToManagersStatic(
            currentBlock, saveObject);

        PerformancePluginCodeGenerator.GenerateEnd(saveObject, currentBlock, addFilesToManagers);
        PerformancePluginCodeGenerator.GenerateStart("Create layer instances");

        #region First generate all code for Layers before other stuff
        // We want the code for Layers to be generated before other stuff
        // since Layes may be used when generating the objects
        foreach (NamedObjectSave nos in saveObject.NamedObjects)
        {
            if ( nos.SourceType == SourceType.FlatRedBallType && nos.GetAssetTypeInfo()?.FriendlyName == "Layer")
            {
                NamedObjectSaveCodeGenerator.WriteAddToManagersForNamedObject(saveObject, nos, currentBlock);

                foreach (CustomVariable customVariable in saveObject.CustomVariables)
                {
                    if (customVariable.SourceObject == nos.InstanceName)
                    {
                        CustomVariableCodeGenerator.AppendAssignmentForCustomVariableInElement(currentBlock, customVariable, saveObject as GlueElement);
                    }
                }    
            }
        }
        #endregion

        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("General AddToManagers code");

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation)
            .Where(item => item.CodeLocation == CodeLocation.BeforeStandardGenerated))
        {
            codeGenerator.GenerateAddToManagers(currentBlock, saveObject);
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation)
            .Where(item => item.CodeLocation == CodeLocation.StandardGenerated))
        {
            codeGenerator.GenerateAddToManagers(currentBlock, saveObject);
        }
        PerformancePluginCodeGenerator.GenerateEnd();

        PerformancePluginCodeGenerator.GenerateStart("Add to managers base and bottom up");

        if ( saveObject.InheritsFromElement())
        {
            currentBlock.Line(saveObject is ScreenSave
                ? "base.AddToManagers();"
                : "base.AddToManagers(layerToAddTo);");
        }
        else
        {
            if (isScreen)
            {
                if (! saveObject.InheritsFromElement())
                {
                    // Screen will always call base.AddToManagers so that
                    // Screen.cs gets a chance to set up its timing
                    currentBlock.Line("base.AddToManagers();");
                }
                currentBlock.Line("AddToManagersBottomUp();");

                if(!saveObject.InheritsFromElement())
                {
                    if (GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.SupportsEditMode)
                    {
                        currentBlock.Line("BeforeCustomInitialize?.Invoke();");
                    }
                }
            }
            else
            {
                currentBlock.Line("AddToManagersBottomUp(layerToAddTo);");
            }
        }


        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .OrderBy(item => (int)item.CodeLocation)
            .Where(item => item.CodeLocation == CodeLocation.AfterStandardGenerated))
        {
            codeGenerator.GenerateAddToManagers(currentBlock, saveObject);
        }



        PerformancePluginCodeGenerator.GenerateEnd();


        // The code for custom variables
        // used to be up in Initialize, but
        // it probably belongs in AddToManagers.
        // See the note in Initialize for more information.

        // UPDATE:  Nevermind, we don't want custom variable
        // setting to be done here because if so then the variables
        // won't be available to the user in CustomInitialize
        PerformancePluginCodeGenerator.GenerateStart("Custom Initialize");
        currentBlock.Line("CustomInitialize();");
        PerformancePluginCodeGenerator.GenerateEnd();
        
    }


    /// <summary>
    /// Generate the AddToManagersBottomUp method for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="currentBlock">Code block to write the method to.</param>
    private static void GenerateAddThisEntityToManagers(IElement saveObject, ICodeBlock currentBlock)
    {
        if (saveObject is not EntitySave entitySave)
        {
            return;
        }

        PerformancePluginCodeGenerator.GenerateStart("Add this to managers");

        if (saveObject.InheritsFromFrbType())
        {
            AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(saveObject.BaseObject, saveObject);

            if (ati != null)
            {
                int addMethodIndex = 0;

                NamedObjectSave isContainerNos = saveObject.AllNamedObjects.FirstOrDefault(item => item.IsContainer);

                if (isContainerNos != null && isContainerNos.IsZBuffered &&
                    (isContainerNos.SourceClassType == "Sprite" || isContainerNos.SourceClassType == "SpriteFrame"))
                {
                    addMethodIndex = 1;
                }

                if(entitySave.IsManuallyUpdated)
                {
                    if (!String.IsNullOrEmpty(ati.AddManuallyUpdatedMethod))
                    {
                        string line = ati.AddManuallyUpdatedMethod
                            .Replace("{THIS}", "this")
                            .Replace("{LAYER}", "layerToAddTo") + ';';
                        currentBlock.Line(line);
                    }
                    else
                    {
                        // not adding this to managers 
                    }

                }
                else if(ati.AddToManagersFunc != null)
                {
                    currentBlock.Line(ati.AddToManagersFunc(saveObject, null, null, "layerToAddTo"));
                }
                else if (ati.LayeredAddToManagersMethod.Count != 0)
                {
                    // just use the method as-is, because the template is already using "this"
                    currentBlock.Line(ati.LayeredAddToManagersMethod[addMethodIndex].Replace("mLayer", "layerToAddTo") + ";");
                }
                else if (ati.AddToManagersMethod.Count != 0)
                {
                    currentBlock.Line(ati.AddToManagersMethod[addMethodIndex] + ";");
                }
            }
        }
        else if (!saveObject.InheritsFromElement())
        {
            currentBlock.Line(entitySave.IsManuallyUpdated
                ? "// This entity skips adding itself to FRB Managers because it has its IsManuallyUpdated property set to true"
                : "FlatRedBall.SpriteManager.AddPositionedObject(this);");
        }
 
        IWindowCodeGenerator.TryGenerateAddToManagers(currentBlock, saveObject);

        PerformancePluginCodeGenerator.GenerateEnd();
    }

    #endregion

    #region Activity

    /// <summary>
    /// Generate activity for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateActivity(ICodeBlock codeBlock, IElement saveObject)
    {

        string activityPre = "public virtual void";
        string activityParameters = "";

        if (saveObject is ScreenSave)
        {
            activityPre = "public override void";
            activityParameters = "bool firstTimeCalled";
        }
        else if (saveObject.InheritsFromElement())
        {
            activityPre = "public override void";
        }
        codeBlock = codeBlock.Function(activityPre, "Activity", activityParameters);

        #region Plugin code generation before standard generation

        List<PluginManagerBase> pluginManagers = PluginManagerBase.GetInstances();
        ICodeBlock currentBlock = codeBlock;

        foreach (PluginManager pluginManager in pluginManagers.Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.GenerateActivityPluginCode(CodeLocation.BeforeStandardGenerated, pluginManager, codeBlock, saveObject);
        }
        #endregion

        if (saveObject is ScreenSave screenSave)
        {
            currentBlock = currentBlock
                .If("!IsPaused");

            GenerateGeneralActivity(currentBlock, saveObject);

            currentBlock = currentBlock
                .End();


            currentBlock = currentBlock
                .Else();

            GeneratePauseIgnoringActivity(currentBlock, screenSave);

            currentBlock = currentBlock
                .End();

            currentBlock.Line("base.Activity(firstTimeCalled);");
            currentBlock
                .If("!IsActivityFinished")
                    .Line("CustomActivity(firstTimeCalled);");

        }
        else
        {
            EntityCodeWriter.GenerateActivity(saveObject as EntitySave, codeBlock);

            GenerateGeneralActivity(currentBlock, saveObject);

            currentBlock.Line("CustomActivity();");

        }


        GenerateAfterActivity(codeBlock, saveObject);
        
    }

    /// <summary>
    /// Generate activity edit mode for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    private static void GenerateActivityEditMode(ICodeBlock codeBlock, GlueElement saveObject)
    {
         bool inherits = saveObject is ScreenSave || saveObject.InheritsFromElement();
         
        ICodeBlock currentBlock = codeBlock.Function(
            inherits ? "public override void" : "public virtual void",
            "ActivityEditMode", "");

        if(saveObject is ScreenSave)
        {
            currentBlock = currentBlock.If("FlatRedBall.Screens.ScreenManager.IsInEditMode");
        }

        if(GlueState.Self.CurrentGlueProject.FileVersion >= (int)GlueProjectSave.GluxVersions.IEntityInFrb)
        {
            if(saveObject is ScreenSave && !saveObject.InheritsFromElement())
            {
                // The internal call could add or remove things from the FRB engine so we shouldn't foreach here. Reverse loop it instead:
                //var foreachBlock = currentBlock.ForEach($"var item in FlatRedBall.SpriteManager.ManagedPositionedObjects");
                ICodeBlock forBlock = currentBlock.For("int i = FlatRedBall.SpriteManager.ManagedPositionedObjects.Count - 1; i > -1; i--");
                forBlock.Line("var item = FlatRedBall.SpriteManager.ManagedPositionedObjects[i];");
                ICodeBlock foreachIfBlock = forBlock.If("item is FlatRedBall.Entities.IEntity entity");
                foreachIfBlock.Line("entity.ActivityEditMode();");
            }
        }
        else
        {
            // Old version (before file version 10 in Dec 24 2021) required code gen to call custom activity.
            foreach(NamedObjectSave nos in saveObject.NamedObjects)
            {
                if(!nos.DefinedByBase && !nos.IsDisabled)
                {
                    if(nos.SourceType == SourceType.Entity)
                    {
                        currentBlock.Line($"{nos.InstanceName}.ActivityEditMode();");
                    }
                    else if(nos.IsList && ObjectFinder.Self.GetEntitySave(nos.SourceClassGenericType) != null)
                    {
                        ICodeBlock foreachBlock = currentBlock.ForEach($"var item in {nos.InstanceName}");
                        foreachBlock.Line($"item.ActivityEditMode();");
                    }
                }
            }
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateActivityEditMode(currentBlock, saveObject);
        }

        currentBlock.Line("CustomActivityEditMode();");

        if(inherits)
        {
            currentBlock.Line("base.ActivityEditMode();");
        }
    }


    /// <summary>
    /// Generate the AfterActivity method for the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static ICodeBlock GenerateGeneralActivity(ICodeBlock codeBlock, IElement saveObject)
    {
        bool isEntity = saveObject is EntitySave;
        EntitySave entitySave = saveObject as EntitySave;

        // This code might seem a little weird.  The reason we do this
        // is that when an Entity is paused, it has a method that is
        // called.  However, when it is unpaused, there's just an instruction
        // that is executed - there is no event.  But if a Screen is paused, then
        // objects within that Screen don't get unpaused....so we're going to bet on
        // the Activity function only being called in unpaused Screens.  If this causes
        // problems we may have to make something a little more standard like an Unpause
        // method.
        if (isEntity &&
            (entitySave.ImplementsIClickable || entitySave.ImplementsIWindow)
            && !entitySave.GetInheritsFromIWindowOrIClickable()
            )
        {
            codeBlock.Line("mIsPaused = false;");
        }

        #region Call base.Activity if it has a derived object

        // We only need to do this for EntitySaves.  Screens inherit from the
        // Screen class, so they ALWAYS call base.Activity.  It's in the generated
        // Screen template.  
        if ( saveObject.InheritsFromEntity())
        {
            codeBlock.Line("base.Activity();");
        }

        #endregion

        codeBlock._();

        // Eventually do we want to move this in the generate activity for custom variable code gen.
        CustomVariableCodeGenerator.WriteVelocityForCustomVariables(saveObject.CustomVariables, codeBlock);

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateActivity(codeBlock, saveObject);
        }

        return codeBlock;
    }

    #endregion

    /// <summary>
    /// Generate the Destroy() method of the specified <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="codeBlock">Code block to write the method to.</param>
    internal static void GenerateDestroy(IElement saveObject, ICodeBlock codeBlock)
    {

        string destroyPre = "public virtual void";

        bool destroyInherits = saveObject is ScreenSave || saveObject.InheritsFromElement();

        if (destroyInherits)
        {
            destroyPre = "public override void";
        }

        codeBlock = codeBlock.Function(destroyPre, "Destroy", "");

        bool isScreen = saveObject is ScreenSave;
        ICodeBlock currentBlock = codeBlock;


        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            // eventually split these up:
            .Where(item => item.CodeLocation == CodeLocation.BeforeStandardGenerated))
        {
            codeGenerator.GenerateDestroy(currentBlock, saveObject);
        }


        #region Call base.Destroy if it has a derived object

        if (saveObject.InheritsFromEntity() || saveObject is ScreenSave)
        {
            currentBlock.Line("base.Destroy();");
        }

        #endregion


        #region If Entity, remove from managers (SpriteManager, GuiManager)

        if (saveObject is EntitySave entitySave)
        {
            if (entitySave.InheritsFromFrbType())
            {
                AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(saveObject.BaseObject, entitySave);

                if (ati != null)
                {
                    if(ati.DestroyFunc != null)
                    {
                        currentBlock.Line(ati.DestroyFunc(entitySave, null, null));
                    }
                    else
                    {
                        currentBlock.Line(ati.DestroyMethod + ";");
                    }
                }
            }
            else if (!entitySave.InheritsFromElement())
            {
                currentBlock.Line("FlatRedBall.SpriteManager.RemovePositionedObject(this);");
            }

            if (entitySave.ImplementsIWindow && !entitySave.GetInheritsFromIWindow())
            {
                currentBlock.Line("FlatRedBall.Gui.GuiManager.RemoveWindow(this);");
            }

        }

        #endregion

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            // eventually split these up:
            .Where(item => item.CodeLocation == CodeLocation.AfterStandardGenerated || item.CodeLocation == CodeLocation.StandardGenerated))
        {
            codeGenerator.GenerateDestroy(currentBlock, saveObject);
        }

        // Sept 9, 2022
        // Not sure if this should be at the beginning or end, but adding this
        // at the end, so it doesn't interrupt any other unload code:
        GenerateUnloadContentManager(saveObject as GlueElement, currentBlock);

        codeBlock.Line("CustomDestroy();");
    }
 
    /// <summary>
    /// Generate UnloadContentManager() for <paramref name="saveObject"/>
    /// </summary>
    /// <param name="saveObject">Element to write the method for.</param>
    /// <param name="currentBlock">Code block to write the method to.</param>
    private static void GenerateUnloadContentManager(GlueElement saveObject, ICodeBlock currentBlock)
    {
        bool shouldUnload = 
            saveObject is ScreenSave screenSave && 
            screenSave.UseGlobalContent == false &&
            screenSave.ReferencedFiles.Any(item => item.LoadedOnlyWhenReferenced);

        // This code could be in a screen that is the base
        // for a derived screen (such as GameScreen for Level1)
        // In that case, Level1 would use its own content manager,
        // but when the LoadedOnlyWhenReferenced property is accessed,
        // the base content manager would get used. Screens automatically
        // clean up their content managers at the engine level, but only the
        // content manager specified by the most derived.

        if (shouldUnload)
        {
            currentBlock.Line($"FlatRedBall.FlatRedBallServices.Unload(\"{saveObject.ClassName}\");");
        }
    }

    /// <summary>
    /// Generate a class based on the specified properties.
    /// </summary>
    /// <param name="classProperties">Properties</param>
    /// <returns>Generated code block.</returns>
    public static ICodeBlock CreateClass(ClassProperties classProperties)
    {
        return CreateClass(classProperties.NamespaceName, classProperties.ClassName, classProperties.Partial, classProperties.Members,
            classProperties.IsStatic, classProperties.UsingStatements, classProperties.UntypedMembers,
            classProperties.MethodContent);
    }
    
    /// <summary>
    /// Generate a class based on the specified properties.
    /// </summary> 
    /// <param name="namespaceName">Namespace the class belongs to</param>
    /// <param name="className">Name of the class</param>
    /// <param name="members">Member methods of the class</param>
    /// <returns>Generated code block.</returns>
    public static ICodeBlock CreateClass(string namespaceName, string className, List<TypedMemberBase> members)
    {
        return CreateClass(namespaceName, className, false, members, false,
            new List<string>(), new Dictionary<string, string>(), null);
    }
    
    /// <summary>
    /// Generate a class based on the specified properties.
    /// </summary>
    /// <param name="namespaceName">Namespace the class belongs to</param>
    /// <param name="className">Name of the class</param>
    /// <param name="isPartial">Whether this is a partial class</param>
    /// <param name="members">Member methods of the class</param>
    /// <param name="isStatic">Whether this is a static class</param>
    /// <param name="usingStatements">Using statements at the top of the file.</param>
    /// <param name="untypedMembers">Untyped members of the class</param>
    /// <param name="methodContent">Content of the methods of the class</param>
    /// <returns>Generated code block.</returns>
    public static ICodeBlock CreateClass(string namespaceName, string className, bool isPartial, List<TypedMemberBase> members,
        bool isStatic, List<string> usingStatements, Dictionary<string, string> untypedMembers, ICodeBlock methodContent)
    {
        CodeDocument codeBlock = new();

        #region Append Using Statements
        foreach(string usingStatement in usingStatements.Distinct())
        {
            codeBlock.Line("using " + usingStatement + ";");
        }
        #endregion

        #region Append Namespace

        codeBlock._();

        ICodeBlock currentBlock = codeBlock;

        currentBlock = currentBlock.Namespace(namespaceName);

        #endregion

        #region Append class header

        currentBlock = currentBlock.Class(pName: className, Public: true, Static: isStatic, Partial: isPartial);

        #endregion

        foreach (TypedMemberBase member in members)
        {
            bool isPublic = member.Modifier == Modifier.Public;
            bool isPrivate = member.Modifier == Modifier.Private;
            bool isInternal = member.Modifier == Modifier.Internal;

            string memberType = member.MemberType.ToString();

            memberType = PrepareTypeToBeWritten(member, memberType);

            // We used to remove whitespace here,
            // but the member name may contain an assignment.
            // In that case we want spaces preserved.  Whatever
            // calls this method is in charge of removing whitespace.
            string memberName = member.MemberName;

            currentBlock.Line(StringHelper.Modifiers(
                Public: isPublic, 
                Private: isPrivate,
                Internal: isInternal,
                Static: isStatic, 
                Type: memberType, 
                Name: memberName) + ";");
        }

        foreach ((string memberName, string type) in untypedMembers)
        {
            bool isPublic = !memberName.StartsWith("m");
            currentBlock.Line(StringHelper.Modifiers(Public: isPublic, Static: isStatic, Type: type, Name: memberName) + ";");
        }

        if (methodContent == null)
        {
            currentBlock.Tag("Methods");
        }
        else
        {
            currentBlock.InsertBlock(methodContent);
        }

        currentBlock._()._();

        currentBlock.Replace(" System.Single ", " float ");
        currentBlock.Replace(" System.Boolean ", " bool ");
        currentBlock.Replace(" System.Int32 ", " int ");
        currentBlock.Replace(" System.String ", " string ");

        if(members.Any(item => item.MemberName == "Name" && item.MemberType == typeof(string)))
        {
            currentBlock.Line("public override string ToString() => Name;");
        }

        return codeBlock;
    }

    /// <summary>
    /// Prepare Type for writing
    /// </summary>
    /// <param name="member">Member to prepare</param>
    /// <param name="memberType">Type of the member.</param>
    /// <returns>Altered <paramref name="memberType"/></returns>
    private static string PrepareTypeToBeWritten(TypedMemberBase member, string memberType)
    {
        if (memberType.Contains("`1"))
        {
            // This is generic
            string name = memberType[..memberType.IndexOf('`')];

            // We want to use FullName rather than Name so we don't rely on using's in generated code
            //string genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].Name);
            string genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].FullName);

            memberType = $"{name}<{genericContents}>";
        }
        else if (memberType.Contains('<'))
        {
            string name = memberType[..memberType.IndexOf('<')];

            // See above
            //string genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].Name);
            string genericContents = PrepareTypeToBeWritten(null, member.MemberType.GetGenericArguments()[0].FullName);

            memberType = $"{name}<{genericContents}>";
        }
        else
        {
            memberType = TypeManager.GetCommonTypeName(memberType);
        }

        // Fully qualify FRB names to prevent clashes with 
        if(memberType.Contains("FlatRedBall."))
        {
            memberType = "global::" + memberType;
        }


        return memberType;
    }
 
    /// <summary>
    /// Set the base class of the generated file.
    /// </summary>
    /// <param name="fileName">Location of the file to be generated</param>
    /// <param name="baseClass">Name of the base class</param>
    public static void SetBaseClass(string fileName, string baseClass)
    {
        SetBaseClass(fileName, baseClass, out string fileContents);

        FileManager.SaveText(fileContents, fileName + ".Generated.cs");
    }

    /// <summary>
    /// Set the base class of the generated file.
    /// </summary>
    /// <param name="fileName">Location of the file to be generated</param>
    /// <param name="baseClass">Name of the base class</param>
    /// <param name="fileContents">File contents for the generated class</param>
    public static void SetBaseClass(string fileName, string baseClass, out string fileContents)
    {
        SetBaseClass(fileName, baseClass, true, out fileContents);
    }

    /// <summary>
    /// Set the base class of the generated file.
    /// </summary>
    /// <param name="fileName">Location of the file to be generated</param>
    /// <param name="baseClass">Name of the base class</param>
    /// <param name="overwrite">Whether to overwrite existing content</param>
    /// <param name="fileContents">File contents for the generated class</param>
    public static void SetBaseClass(string fileName, string baseClass, bool overwrite, out string fileContents)
    {
        fileContents = FileManager.FromFileText(fileName + ".Generated.cs");

        SetBaseClass(ref fileContents, baseClass, overwrite);

    }

    /// <summary>
    /// Set the base class of the generated file.
    /// </summary> 
    /// <param name="baseClass">Name of the base class</param>
    /// <param name="overwrite">Whether to overwrite existing content</param>
    /// <param name="fileContents">File contents for the generated class</param>
    public static void SetBaseClass(ref string fileContents, string baseClass, bool overwrite)
    {
        string wordAfter = StringFunctions.GetWordAfter(" : ", fileContents);

        if (overwrite)
        {
            fileContents = fileContents.Replace(" : " + wordAfter, " : " + baseClass);
        }
        else
        {
            string contents = " : " + wordAfter;
            int index = fileContents.IndexOf(contents, StringComparison.Ordinal) + contents.Length;
            fileContents = fileContents.Insert(index, ", " + baseClass);
        }

    }
 
    /// <summary>
    /// Initializes the static data for the game.
    /// </summary>
    /// <param name="relativeGameFileName">Path to the file where the static data is located.</param>
    public static void InitializeStaticData(string relativeGameFileName)
    {
        if (String.IsNullOrEmpty(relativeGameFileName))
        {
            return;
        }
        FilePath gameFilePath = new(GlueState.Self.CurrentMainProject.Directory + relativeGameFileName);

        string contents = FileManager.FromFileText(gameFilePath.FullPath);
        string contentsBeforeChange = contents;
        int gluxVersion = GlueState.Self.CurrentGlueProject.FileVersion;
        if(gluxVersion < (int)GlueProjectSave.GluxVersions.HasGame1GenerateEarly)
        {
            AddGlobalContentInitializeInCustomCode(ref contents);
        }

        if(contents != contentsBeforeChange)
        {
            if (new FileInfo(gameFilePath.FullPath).IsReadOnly)
            {
                GlueGui.ShowMessageBox("The file\n\n" + gameFilePath + "\n\nis read-only, so Glue can't generate code");
            }
            else
            {
                FileWatchManager.IgnoreNextChangeOnFile(gameFilePath.Standardized);
                try
                {
                    GlueCommands.Self.TryMultipleTimes(() =>
                    {
                        FileManager.SaveText(contents, gameFilePath.FullPath);
                    });
                }
                catch 
                {
                    // If we failed, save a backup
                    FileManager.SaveText(contents, gameFilePath.FullPath + ".Backup");
                    throw;
                }
            }
        }
    }
  
    /// <summary>
    /// Add GlobalContent.Initialize(); to custom code.
    /// </summary>
    /// <param name="contents">Existing contents (in string format)</param>
    /// <exception cref="CodeParseException">Thrown if the method cannot be placed anywhere.</exception>
    private static void AddGlobalContentInitializeInCustomCode(ref string contents)
    {
        const string lineToReplaceWith = "            " + "GlobalContent.Initialize();";

        if (contents.Contains("GlobalContent.Initialize"))
        {
            StringFunctions.ReplaceLine(ref contents, "GlobalContent.Initialize", lineToReplaceWith);
        }
        else
        {
            // We have to find where to put the start call.  This should be after 
            // FlatRedBallServices.InitializeFlatRedBall

            int index = CodeParser.GetIndexAfterFlatRedBallInitialize(contents);

            if (index == -1)
            {
                throw new CodeParseException("Could not find FlatRedBall.Initialize in the Game file.  Did you delete this?  " +
                    "Glue requires this call to be in the Game class. You must manually add this call and reload Glue.");
            }
            contents = contents.Insert(index, lineToReplaceWith + Environment.NewLine);
        }
    }

    /// <summary>
    /// Replaces the namespace with a new name.
    /// </summary>
    /// <param name="fileContents">Existing file contents</param>
    /// <param name="newNamespace">New namespace name.</param>
    /// <returns>Altered <paramref name="fileContents"/></returns>
    internal static string ReplaceNamespace(string fileContents, string newNamespace)
    {
        return ReplaceNamespace(fileContents, newNamespace, out string _);
    }

    /// <summary>
    /// Replaces the namespace with a new name.
    /// </summary>
    /// <param name="fileContents">Existing file contents</param>
    /// <param name="newNamespace">New namespace name.</param>
    /// <param name="oldNamespace">Old namespace name.</param>
    /// <returns>Altered <paramref name="fileContents"/></returns>
    internal static string ReplaceNamespace(string fileContents, string newNamespace, out string oldNamespace)
    {
        int indexOfNamespaceKeyword = fileContents.IndexOf("namespace ", StringComparison.Ordinal);
        oldNamespace = "";
        if(indexOfNamespaceKeyword != -1)
        {


            int indexOfNamespaceStart = indexOfNamespaceKeyword + "namespace ".Length;

            int indexOfSlashR = fileContents.IndexOf("\r", indexOfNamespaceStart, StringComparison.Ordinal);
            int indexOfSlashN = fileContents.IndexOf("\n", indexOfNamespaceStart, StringComparison.Ordinal);

            int indexOfEndOfNamespace;

            if (indexOfSlashR == -1)
            {
                indexOfEndOfNamespace = indexOfSlashN;
            }
            else if(indexOfSlashN == -1)
            {
                indexOfEndOfNamespace = indexOfSlashR;
            }
            else
            {
                indexOfEndOfNamespace = System.Math.Min(indexOfSlashR, indexOfSlashN);
            }

            oldNamespace = fileContents.Substring(indexOfNamespaceStart, indexOfEndOfNamespace - indexOfNamespaceStart);


            fileContents = fileContents.Remove(indexOfNamespaceStart, indexOfEndOfNamespace - indexOfNamespaceStart);

            fileContents = fileContents.Insert(indexOfNamespaceStart, newNamespace);

        }
        return fileContents;
    }


    /// <summary>
    /// Set the classname and namespace for the specified <paramref name="elementName"/>.
    /// </summary>
    /// <param name="projectNamespace">Namespace of the project</param>
    /// <param name="elementName">Name of the element</param>
    /// <param name="templateCode">Template code</param>
    public static void SetClassNameAndNamespace(string projectNamespace, string elementName, StringBuilder templateCode)
    {
        SetClassNameAndNamespace(projectNamespace, elementName, templateCode, false, "\"Global\"", null);
    }

    /// <summary>
    /// Set the classname and namespace for the specified <paramref name="elementName"/>.
    /// </summary>
    /// <param name="classNamespace">Namespace of the class</param>
    /// <param name="elementName">Name of the element</param>
    /// <param name="templateCode">Template code</param>
    /// <param name="useGlobalContent">Whether to use the global content fields</param>
    /// <param name="replacementContentManagerName">The string to replace the content manager name with.</param>
    /// <param name="inheritance">The items the class inherits from.</param>
    public static void SetClassNameAndNamespace(string classNamespace, string elementName, StringBuilder templateCode, bool useGlobalContent, string replacementContentManagerName, string inheritance)
    {
        string namespaceToReplace = StringFunctions.GetWordAfter("namespace ", templateCode);
        bool isScreen = namespaceToReplace.Contains("Screen");
            
        string classNameToReplace = StringFunctions.GetWordAfter("public partial class ", templateCode);
        if (isScreen)
        {
            templateCode.Replace("namespace " + namespaceToReplace,
                "namespace " + classNamespace);
            
            if (useGlobalContent)
            {
                // replace the content manager name with the global content manager
                templateCode.Replace("\"" + classNameToReplace + "\"", replacementContentManagerName);

            }
        }
        else
        {
            string whatToReplaceWith;

            //if (projectNamespace.Contains(".Entities."))
            // Not sure why we require the period at the end of Entities
            if(classNamespace.Contains(".Entities") && classNamespace.IndexOf('.') == classNamespace.IndexOf(".Entities"))
            {
                // This is a full namespace.  Okay, let's just use that
                whatToReplaceWith = "namespace " + classNamespace;
            }
            else
            {
                // We gotta put Entities at the end ourselves
                whatToReplaceWith = "namespace " + classNamespace + ".Entities";
            }

            templateCode.Replace("namespace " + namespaceToReplace,
                whatToReplaceWith);
        }

        if (!String.IsNullOrEmpty(inheritance))
        {
            templateCode.Replace(classNameToReplace,
             elementName);

            int indexOfClass = templateCode.IndexOf("class " + elementName);

            if (indexOfClass != -1)
            {
                int length = ("class " + elementName).Length;
                templateCode.Insert(indexOfClass + length, " : " + inheritance);
            }

        }
        else
        {
            templateCode.Replace(classNameToReplace,
                elementName);
        }
    }

    /// <summary>
    /// Refresh the startup screen code.
    /// </summary>
    internal static void RefreshStartupScreenCode()
    {
        // If there is a required screen, then use that
        ScreenSave requiredScreen = ProjectManager.GlueProjectSave.Screens.FirstOrDefault(screenSave => screenSave.IsRequiredAtStartup);

        string screenName = requiredScreen?.Name ?? 
                            GlueCommands.Self.GluxCommands.StartUpScreenName;

        SetStartUpScreen(
            ProjectManager.GameClassFileName,
            screenName);
    }

    /// <summary>
    /// Set the startup screen for the game.
    /// </summary>
    /// <param name="gameFileName">Path to the game file</param>
    /// <param name="startUpScreen">Screen to set as startup screen.</param>
    private static void SetStartUpScreen(string gameFileName, string startUpScreen)
    {
        bool success = true;

        string contents = null;
        try
        {
            contents = FileManager.FromFileText(FileManager.RelativeDirectory + gameFileName);
        }
        catch(Exception e)
        {

            PluginManager.ReceiveError(e.ToString());
            success = false;
        }

        if (success)
        {

            #region Get the lineThatStartsEverything

            // isEmpty needs to get set
            // *before* prepending the ProjectNamespace
            bool isEmpty = String.IsNullOrEmpty(startUpScreen);

            if(!isEmpty)
            {
                startUpScreen = ProjectManager.ProjectNamespace + "." + startUpScreen.Replace("\\", ".");
            }
            string lineThatStartsEverything =
                $"            FlatRedBall.Screens.ScreenManager.Start(typeof({startUpScreen}));";

            if (isEmpty)
            {
                lineThatStartsEverything = "            //FlatRedBall.Screens.ScreenManager.Start(typeof(YourScreenClass));";
            }

            #endregion

            if(contents.Contains("Type startScreenType = "))
            {
                string line = isEmpty ?
                    $"            Type startScreenType = null;" :
                    $"            Type startScreenType = typeof({startUpScreen});";
                // new projects (as of October 25 2019) use this multi-line approach
                StringFunctions.ReplaceLine(ref contents, "Type startScreenType = ", line);

            }
            else if (contents.Contains("ScreenManager.Start"))
            {
                StringFunctions.ReplaceLine(ref contents, "ScreenManager.Start", lineThatStartsEverything);
            }
            else
            {
                // We have to find where to put the start call.  This should be after 
                // FlatRedBallServices.InitializeFlatRedBall

                int index = CodeParser.GetIndexAfterFlatRedBallInitialize(contents);
                contents = contents.Insert(index, lineThatStartsEverything + Environment.NewLine);
            }

            try
            {
                SaveFileContents(contents, FileManager.RelativeDirectory + gameFileName, true);
            }
            catch (Exception e)
            {
                PluginManager.ReceiveError(e.ToString());
            }
        }
    }

    /// <summary>
    /// Generate the PostInitialize() method for the <paramref name="saveObject"/> element.
    /// </summary>
    /// <param name="codeBlock">Code block to write the method to.</param>
    /// <param name="saveObject">Entity to write the code for.</param>
    public static void GeneratePostInitialize(ICodeBlock codeBlock, IElement saveObject)
    {
        // PostInitialize is a method which can be called multiple times if an entity is pooled. Therefore, any "add" calls here must
        // be protected with if-checks.

        ICodeBlock currentBlock = codeBlock;
        bool inheritsFromElement = saveObject.InheritsFromElement();
        currentBlock = currentBlock
            .Function("PostInitialize", "", Public: true, Override: inheritsFromElement, Virtual: !inheritsFromElement, Type: "void");

        // PostInitialize may happen async - but setting Visible = true on a shape
        // adds it to the ShapeManager.  This is bad because:
        // 1.  It's not thread safe
        // 2.  Another Screen may be visible
        // 3.  The ScreenManager checks for the presence of objects in the managers after a Screen is destroyed.  An addition would (and has) cause a crash here
        currentBlock.Line("bool oldShapeManagerSuppressAdd = FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue;");
        currentBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = true;");
        
        // Events need to come first here
        // in case other generators set properties
        // that raise events.
        EventCodeGenerator.GeneratePostInitialize(currentBlock, saveObject);

        if (inheritsFromElement)
        {
            currentBlock.Line("base.PostInitialize();");
        }


        // Do attachments before setting any variables (which may call events)
        NamedObjectSaveCodeGenerator.GetPostInitializeForNamedObjectList(null, 
            // There may be a race condition so handle it by to-listing it
            saveObject.NamedObjects.ToList(), 
            currentBlock, saveObject as GlueElement);

        currentBlock = CodeGenerators.OrderBy(item => (int)item.CodeLocation).Aggregate(currentBlock, (current, codeGenerator) => codeGenerator.GeneratePostInitialize(current, saveObject));
        foreach (ReferencedFileSave rfs in from rfs in saveObject.ReferencedFiles let ati = rfs.GetAssetTypeInfo() where !rfs.IsSharedStatic && ati != null && !String.IsNullOrEmpty(ati.PostInitializeCode) select rfs)
        {
            currentBlock.InsertBlock(ReferencedFileSaveCodeGenerator.GetPostInitializeForReferencedFile(rfs));
        }
        currentBlock.Line("FlatRedBall.Math.Geometry.ShapeManager.SuppressAddingOnVisibilityTrue = oldShapeManagerSuppressAdd;");
    }


    /// <summary>
    /// Generate AfterActivity() for the <paramref name="saveObject"/>
    /// </summary>
    /// <param name="codeBlock">Code block to write the element for.</param>
    /// <param name="saveObject">Element to write the code block for.</param>
    public static ICodeBlock GenerateAfterActivity(ICodeBlock codeBlock, IElement saveObject)
    {
        #region Loop through all ReferenceFiles to get their post custom activity code

        foreach (ReferencedFileSave referencedFile in saveObject.ReferencedFiles)
        {
            codeBlock.InsertBlock(ReferencedFileSaveCodeGenerator.GetPostCustomActivityForReferencedFile(referencedFile));
        }

        #endregion

        #region Loop through all NamedObjectSaves to get their post custom activity code

        foreach (NamedObjectSave namedObject in saveObject.NamedObjects)
        {
            NamedObjectSaveCodeGenerator.GetPostCustomActivityForNamedObjectSave(saveObject, namedObject, codeBlock);
        }
        #endregion
        
        foreach (PluginManager pluginManager in PluginManagerBase.GetInstances().Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.GenerateActivityPluginCode(CodeLocation.AfterStandardGenerated,
                pluginManager, codeBlock, saveObject);
        }
        

        return codeBlock;
    }


    /// <summary>
    /// Localizes the contents (if necessary)
    /// </summary>
    /// <param name="namedObject">Named object</param>
    /// <param name="variableName">Name of the variable</param>
    /// <param name="valueAsObject">Value of the variable (as object)</param>
    /// <param name="valueAsString">Value of the variable (as string)</param>
    /// <param name="customVariable">Established variable</param>
    /// <returns>Localized string, or the default input.</returns>
    public static string MakeLocalizedIfNecessary(NamedObjectSave namedObject, string variableName, object valueAsObject, string valueAsString, CustomVariable customVariable)
    {
        // This code will convert something like
        //      someVariable = "Hello";
        // to
        //      someVariable = LocalizationManager.Translate("Hello");

        // This code gets called on states.
        // If it's a state, then we find the 
        // custom variable that the state represents
        // and pass it as the last argument in the method.
        // We can look at that custom variable to see if it's
        // an AnimationChain

        bool shouldTranslate = false;

        if (ObjectFinder.Self.GlueProject != null && 
            ObjectFinder.Self.GlueProject.UsesTranslation && 
            valueAsObject is string && (customVariable == null || customVariable.Type != "Color"))//&& !namedObject.IsAnimationChain)
        {
            if (customVariable != null && customVariable.GetIsAnimationChain())
            {
                // do nothing
            }
            else if (namedObject is { SourceType: SourceType.File })
            {
                if (!String.Equals(variableName, "CurrentChain",
                        StringComparison.OrdinalIgnoreCase) // CurrentChain is used by some FRB types
                    && !String.Equals(variableName, "CurrentChainName",
                        StringComparison.OrdinalIgnoreCase) // and CurrentChainName is used by others....sucky.
                    )
                {
                    shouldTranslate = true;
                }
            }
            else if (namedObject is { SourceType: SourceType.Entity })
            {
                EntitySave entitySave = ObjectFinder.Self.GetEntitySave(namedObject.SourceClassType);

                if (entitySave != null)
                {
                    CustomVariable variableInEntity = entitySave.GetCustomVariable(variableName);

                    if (variableInEntity == null || variableInEntity.GetIsAnimationChain() == false)
                    {
                        shouldTranslate = true;
                    }
                }
            }
            else if (namedObject != null && namedObject.SourceType == SourceType.FlatRedBallType)
            {
                if (namedObject.GetAssetTypeInfo() == AvailableAssetTypes.CommonAtis.Text && variableName == "DisplayText")
                {
                    shouldTranslate = true;
                }
            } 
        }

        if(shouldTranslate)
        {
            valueAsString = "FlatRedBall.Localization.LocalizationManager.Translate(" + valueAsString + ")";
        }

        return valueAsString;
    }
 
    /// <summary>
    /// Add event generated code for the element
    /// </summary>
    /// <param name="element">Element to generated code for</param>
    internal static void AddEventGeneratedCodeFileForElement(IElement element)
    {

        string fileName = element.Name + ".Generated.Event.cs";
        string fullFileName = GlueState.Self.CurrentMainProject.Directory + fileName;

        bool save = false; // we'll be doing manual saving after it's created
        ProjectManager.CodeProjectHelper.CreateAndAddPartialGeneratedCodeFile(fileName, save);

        FileWatchManager.IgnoreNextChangeOnFile(fullFileName);
        FileManager.SaveText("// Empty event file - code will be added here if events are added in Glue", fullFileName);
    }


    /// <summary>
    /// Generate AddToManagersBottomUp() method for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to be written</param>
    internal static void GenerateAddToManagersBottomUp(ICodeBlock codeBlock, IElement element)
    {
        bool isEntity = element is EntitySave;
        bool isScreen = element is ScreenSave;

        bool inheritsFromElement = element.InheritsFromElement();

        string layerArgs = "";

        if (isEntity)
        {
            layerArgs = "FlatRedBall.Graphics.Layer layerToAddTo";
        }

        ICodeBlock currentBlock = codeBlock;

        currentBlock = currentBlock
            .Function("AddToManagersBottomUp", layerArgs, Public: true, Override: inheritsFromElement,
                      Virtual: !inheritsFromElement, Type: "void");

        if (inheritsFromElement)
        {
            currentBlock.Line(isEntity ? "base.AddToManagersBottomUp(layerToAddTo);" : "base.AddToManagersBottomUp();");
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .Where(item =>item.CodeLocation == CodeLocation.BeforeStandardGenerated))
        {
            codeGenerator.GenerateAddToManagersBottomUp(currentBlock,element);
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .Where(item => item.CodeLocation == CodeLocation.StandardGenerated))
        {
            codeGenerator.GenerateAddToManagersBottomUp(currentBlock, element);
        }


        if (isScreen && String.IsNullOrEmpty(element.BaseElement))
        {
            currentBlock.Line("CameraSetup.ResetCamera(SpriteManager.Camera);");
        }

        if (!element.InheritsFromElement())
        {
            currentBlock.Line("AssignCustomVariables(false);");
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators
            .Where(item => item.CodeLocation == CodeLocation.AfterStandardGenerated))
        {
            codeGenerator.GenerateAddToManagersBottomUp(currentBlock, element);
        }
    }

    /// <summary>
    /// Retrieves all code files associated with <paramref name="element"/>
    /// </summary>
    /// <param name="element">Element to retrieve all code files for.</param>
    /// <returns>Stack of file paths.</returns>
    public static List<FilePath> GetAllCodeFilesFor(IElement element)
    {
        string directory = FileManager.GetDirectory(GlueCommands.Self.GetAbsoluteFileName(element.Name + "/", false));


        List<FilePath> foundCsFiles = FileManager.GetAllFilesInDirectory(directory, "cs")
            .Select(item => new FilePath(item)).ToList();

        for (int i = foundCsFiles.Count - 1; i > -1; i--)
        {
            FilePath file = foundCsFiles[i];
            string relativeFile = FileManager.MakeRelative(file.Original).Replace('/', '\\');
            bool isValid = relativeFile.StartsWith(element.Name) && relativeFile[element.Name.Length] == '.';

            if (!isValid)
            {
                foundCsFiles.RemoveAt(i);
            }
        }

        if(element is EntitySave { CreatedByOtherEntities: true })
        {
            string strippedName = FileManager.RemovePath(element.Name);

            // This also has a factory, so check for that.
            string fullName = GlueState.Self.CurrentGlueProjectDirectory + "Factories/" + strippedName + "Factory.Generated.cs";

            foundCsFiles.Add(fullName);
        }

        return foundCsFiles;

    }

    /// <summary>
    /// Generate PauseIgnoringActivity() method for <paramref name="saveObject"/>
    /// </summary>
    /// <param name="codeBlock">Code block to generate code in.</param>
    /// <param name="saveObject">Element to generate code for</param>
    private static void GeneratePauseIgnoringActivity(ICodeBlock codeBlock, GlueElement saveObject)
    {
        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GeneratePauseIgnoringActivity(codeBlock, saveObject);
        }

        foreach (NamedObjectSave namedObject in saveObject.NamedObjects.Where(namedObject => namedObject.IgnoresPausing))
        {
            NamedObjectSaveCodeGenerator.GetActivityForNamedObject(namedObject, codeBlock);
        }
    }


    /// <summary>
    /// Generated UnloadStatic() method for the <paramref name="saveObject"/>
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="saveObject">Element to be written</param>
    /// <returns><paramref name="codeBlock"/>.</returns>
    internal static ICodeBlock GenerateUnloadStaticContent(ICodeBlock codeBlock, IElement saveObject)
    {
        ICodeBlock currentBlock = codeBlock;

        #region Generate UnloadStaticContent

        if (saveObject is not EntitySave)
        {
            return codeBlock;
        }

        currentBlock = currentBlock
            .Function("UnloadStaticContent", "", Public: true, Static: true,
                New: saveObject.InheritsFromElement(), Type: "void");

        // We only want to unload if this isn't using global content
        // If so, then unloading should be a no-op
        if (saveObject.UseGlobalContent == false)
        {

            foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
            {
                currentBlock = codeGenerator.GenerateUnloadStaticContent(currentBlock, saveObject);
            }

        }
        else
        {
            currentBlock.Line("// Intentionally left blank because this element uses global content, so it should never be unloaded");
        }

        #endregion
        return codeBlock;
    }

    /// <summary>
    /// Generates ConvertToManuallyUpdated() method for the <paramref name="saveObject"/>
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="saveObject">Element to be written</param>
    /// <param name="reusableEntireFileRfses">Reusable RFSes.</param>
    internal static void GenerateConvertToManuallyUpdated(ICodeBlock codeBlock, IElement saveObject, Dictionary<string, string> reusableEntireFileRfses)
    {
        bool hasBase = saveObject.InheritsFromElement();

        ICodeBlock currentBlock = codeBlock;

        currentBlock = currentBlock
            .Function("ConvertToManuallyUpdated", "", Public: true, Override: hasBase, Virtual: !hasBase,
                      Type: "void");

        if (hasBase)
        {
            currentBlock.Line("base.ConvertToManuallyUpdated();");
        }

        if (saveObject is EntitySave)
        {

            // It's possible that an Entity may be converted to ManuallyUpdated before
            // any Draw calls get made - this means that UpdateDependencies will never get called.
            // This should happen before the other manual updates are called so that everything is positioned
            // right when verts are created.
            currentBlock.Line("this.ForceUpdateDependenciesDeep();");

            if (saveObject.InheritsFromFrbType())
            {
                AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(saveObject.BaseElement, saveObject);

                if (ati != null)
                {
                    currentBlock.Line(ati.MakeManuallyUpdatedMethod + ";");
                }
            }
            else
            {

                // Convert the Entity itself to manually updated
                currentBlock.Line("FlatRedBall.SpriteManager.ConvertToManuallyUpdated(this);");
            }
        }

        foreach (ReferencedFileSave rfs in saveObject.ReferencedFiles)
        {
            ReferencedFileSaveCodeGenerator.GenerateConvertToManuallyUpdated(currentBlock, rfs);
        }

        NamedObjectSaveCodeGenerator.WriteConvertToManuallyUpdated(currentBlock, saveObject, reusableEntireFileRfses);
    }


    /// <summary>
    /// Generates the methods for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateMethods(ICodeBlock codeBlock, GlueElement element)
    {
        ICodeBlock currentBlock = codeBlock;

        GeneratePostInitialize(codeBlock, element);
        GenerateAddToManagersBottomUp(currentBlock, element);
        GenerateRemoveFromManagers(currentBlock, element);
        GenerateAssignCustomVariables(codeBlock, element);
        GenerateConvertToManuallyUpdated(currentBlock, element, ReusableEntireFileRfses);
        GenerateLoadStaticContent(currentBlock, element);
        currentBlock = GenerateUnloadStaticContent(currentBlock, element);

        if(element is ScreenSave)
        {
            GeneratePauseThisScreen(currentBlock, element);

            GenerateUnpauseThisScreen(currentBlock, element);
        }

        GenerateUpdateDependencies(currentBlock, element);

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            // I see no reason to take the code block
            //currentBlock = codeGenerator.GenerateAdditionalMethods(currentBlock, element);
            codeGenerator.GenerateAdditionalMethods(currentBlock, element);
        }

        currentBlock.Line("partial void CustomActivityEditMode();");

        foreach (PluginManager pluginManager in PluginManagerBase.GetInstances().Cast<PluginManager>())
        {
            CodeGeneratorPluginMethods.GenerateAdditionalMethodsPluginCode(pluginManager, codeBlock, element);
        }

    }

    /// <summary>
    /// Generate PauseThisScreen() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="currentBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GeneratePauseThisScreen(ICodeBlock currentBlock, IElement element)
    {
        ICodeBlock methodBlock = currentBlock.Function("public override void", "PauseThisScreen", "");

        foreach(ElementComponentCodeGenerator generator in CodeGenerators)
        {
            generator.GeneratePauseThisScreen(methodBlock, element);
        }

        methodBlock.Line("base.PauseThisScreen();");
    }
    
    /// <summary>
    /// Generate UnpauseThisScreen() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="currentBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateUnpauseThisScreen(ICodeBlock currentBlock, IElement element)
    {
        ICodeBlock methodBlock = currentBlock.Function("public override void", "UnpauseThisScreen", "");

        foreach (ElementComponentCodeGenerator generator in CodeGenerators)
        {
            generator.GenerateUnpauseThisScreen(methodBlock, element);
        }


        methodBlock.Line("base.UnpauseThisScreen();");

    }

    /// <summary>
    /// Generate UpdateDependencies() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="currentBlock">Code block to write the methods to.</param>
    /// <param name="element">Element to write the code block for.</param>
    private static void GenerateUpdateDependencies(ICodeBlock currentBlock, IElement element)
    {
        // screens will need this too:
        CodeBlockBase innerBlock = new();

        foreach(ElementComponentCodeGenerator generator in CodeGenerators)
        {
            generator.GenerateUpdateDependencies(innerBlock, element);
        }

        if(innerBlock.BodyCodeLines.Any())
        {
            ICodeBlock methodBlock = currentBlock.Function("public override void", "UpdateDependencies", "double currentTime");

            methodBlock.InsertBlock(innerBlock);

            methodBlock.Line("CustomUpdateDependencies(currentTime);");

            currentBlock.Line("partial void CustomUpdateDependencies(double currentTime);");
        }
    }

    /// <summary>
    /// Generate RemoveFromManagers() for the <paramref name="saveObject"/>.
    /// </summary>
    /// <param name="currentBlock">Code block to write the methods to.</param>
    /// <param name="saveObject">Element to write the code block for.</param>
    private static void GenerateRemoveFromManagers(ICodeBlock currentBlock, IElement saveObject)
    {
        if (saveObject.InheritsFromElement())
        {
            currentBlock = currentBlock.Function("public override void", "RemoveFromManagers", "");
            currentBlock.Line("base.RemoveFromManagers();");
        }
        else
        {
            currentBlock = currentBlock.Function("public virtual void", "RemoveFromManagers", "");
        }

        if (saveObject is EntitySave asEntitySave)
        {
            if (asEntitySave.InheritsFromFrbType())
            {
                AssetTypeInfo ati = AvailableAssetTypes.Self.GetAssetTypeFromRuntimeType(saveObject.BaseObject, asEntitySave);

                if (ati != null)
                {
                    if (asEntitySave.CreatedByOtherEntities && !String.IsNullOrEmpty(ati.RecycledDestroyMethod))
                    {
                        currentBlock.Line(ati.RecycledDestroyMethod + ";");
                    }
                    else if(ati.DestroyFunc != null)
                    {
                        currentBlock.Line(ati.DestroyFunc(asEntitySave, null, null));
                    }
                    else
                    {
                        currentBlock.Line(ati.DestroyMethod + ";");
                    }
                }
            }

            else if (!asEntitySave.InheritsFromElement())
            {
                currentBlock.Line("FlatRedBall.SpriteManager.ConvertToManuallyUpdated(this);");
            }

            if (asEntitySave.ImplementsIWindow && !asEntitySave.GetInheritsFromIWindow())
            {
                currentBlock.Line("FlatRedBall.Gui.GuiManager.RemoveWindow(this);");
            }
        }

        foreach (ElementComponentCodeGenerator codeGenerator in CodeGenerators)
        {
            codeGenerator.GenerateRemoveFromManagers(currentBlock, saveObject);
        }
    }
    
    /// <summary>
    /// Generate AssignCustomVariables() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to write to the code block.</param>
    private static void GenerateAssignCustomVariables(ICodeBlock codeBlock, GlueElement element)
    {
        bool inherits = !String.IsNullOrEmpty(element.BaseElement) && !element.InheritsFromFrbType();

        
        if (inherits)
        {
            codeBlock = codeBlock.Function("public override void", "AssignCustomVariables", "bool callOnContainedElements");
            codeBlock.Line("base.AssignCustomVariables(callOnContainedElements);");
        }
        else
        {
            codeBlock = codeBlock.Function("public virtual void", "AssignCustomVariables", "bool callOnContainedElements");
        }

        // call AssignCustomVariables on all contained objects before assigning custom variables on "this"
        ICodeBlock ifCallOnContainedElements = codeBlock.If("callOnContainedElements");

        List<NamedObjectSave> listOfItems = element.NamedObjects.Where(item=>
            item.IsFullyDefined &&
            !item.IsDisabled &&
            item.Instantiate &&
            !item.SetByContainer  
            ).ToList();


        GenerateAssignmentForListOfObjects(codeBlock, element, ifCallOnContainedElements, listOfItems);
 
        foreach (CustomVariable customVariable in element.CustomVariables)
        { 
            CustomVariableCodeGenerator.AppendAssignmentForCustomVariableInElement(codeBlock, customVariable, element);
        }

        EventCodeGenerator.GenerateAddToManagersBottomUp(codeBlock, element);
    }

    /// <summary>
    /// Generate AssignCustomVariables() for the <paramref name="element"/>.
    /// </summary>
    /// <param name="codeBlock">Code block to write the element to</param>
    /// <param name="element">Element to write to the code block.</param>
    /// <param name="ifCallOnContainedElements">Code block that is utilized if subitems exist in the stack.</param>
    /// <param name="listOfItems">List of items to generate assignments for.</param>
    private static void GenerateAssignmentForListOfObjects(ICodeBlock codeBlock, IElement element, ICodeBlock ifCallOnContainedElements, List<NamedObjectSave> listOfItems)
    {
        foreach (NamedObjectSave item in listOfItems)
        {
            if (item.DefinedByBase == false && item.SourceType == SourceType.Entity)
            {
                NamedObjectSaveCodeGenerator.AddIfConditionalSymbolIfNecesssary(ifCallOnContainedElements, item);

                ifCallOnContainedElements.Line(item.InstanceName + ".AssignCustomVariables(true);");
                NamedObjectSaveCodeGenerator.AddEndIfIfNecessary(ifCallOnContainedElements, item);
            }

            NamedObjectSaveCodeGenerator.AddIfConditionalSymbolIfNecesssary(codeBlock, item);

            ICodeBlock innerBlock = codeBlock;
            if(item.SetByDerived)
            {
                innerBlock = codeBlock.If($"{item.InstanceName} != null");
            }
            NamedObjectSaveCodeGenerator.AssignInstanceVariablesOn(element, item, innerBlock);


            List<NamedObjectSave> containedItems = item.ContainedObjects.Where(containedObject =>
                containedObject.IsFullyDefined &&
                !containedObject.IsDisabled &&
                containedObject.Instantiate &&
                !containedObject.SetByContainer &&
                !containedObject.SetByDerived
                ).ToList();

            GenerateAssignmentForListOfObjects(codeBlock, element, ifCallOnContainedElements, containedItems);
            NamedObjectSaveCodeGenerator.AddEndIfIfNecessary(codeBlock, item);

        }
    }

    /// <summary>
    /// Returns <see langword="true"/> if the variable is handled by a custom code generator.
    /// </summary>
    /// <param name="customVariable">Custom variable to check</param>
    /// <param name="element">Element to check that the <paramref name="customVariable"/> belongs to.</param>
    /// <returns><see langword="true"/> if the variable is handled by a custom code generator.</returns>
    internal static bool IsVariableHandledByCustomCodeGenerator(CustomVariable customVariable, IElement element)
        => CodeGenerators.Any(codeGenerator => codeGenerator.HandlesVariable(customVariable, element));

    #endregion
}
